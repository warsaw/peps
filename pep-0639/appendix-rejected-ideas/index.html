
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>Appendix: Rejected Ideas | peps.python.org</title>
    <link rel="shortcut icon" href="../../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0639/appendix-rejected-ideas/">
    <link rel="stylesheet" href="../../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='Appendix: Rejected Ideas | peps.python.org'>
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0639/appendix-rejected-ideas/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="Python Enhancement Proposals (PEPs)">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../../pep-0000/">PEP Index</a> &raquo; </li>
                <li>Appendix: Rejected Ideas</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="appendix-rejected-ideas">
<span id="rejected-ideas-details"></span><h1>Appendix: Rejected Ideas</h1>
<section id="abstract">
<h2>Abstract</h2>
<p>This document contains a list of the alternative ideas to the ones proposed
in PEP 639 with detailed explanations why they were rejected.</p>
</section>
<section id="core-metadata-fields">
<h2>Core metadata fields</h2>
<p>Potential alternatives to the structure, content and deprecation of the
core metadata fields specified in <a class="pep reference internal" href="../pep-0639/">PEP 639</a>.</p>
<section id="re-use-the-license-field">
<h3>Re-use the <code class="docutils literal notranslate"><span class="pre">License</span></code> field</h3>
<p>Following <a class="reference external" href="https://github.com/pombredanne/spdx-pypi-pep/issues/7">initial discussion</a>, earlier versions of
PEP 639 proposed re-using the existing <code class="docutils literal notranslate"><span class="pre">License</span></code> field, which tools would
attempt to parse as a SPDX license expression with a fallback to free text.
Initially, this would merely cause a warning (or even pass silently),
but would eventually be treated as an error by modern tooling.</p>
<p>This offered the potential benefit of greater backwards-compatibility,
easing the community into using SPDX license expressions while taking advantage
of packages that already have them (either intentionally or coincidentally),
and avoided adding yet another license-related field.</p>
<p>However, following substantial discussion, consensus was reached that a
dedicated <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field was the preferred overall approach.
The presence of this field is an unambiguous signal that a package
intends it to be interpreted as a valid SPDX identifier, without the need
for complex and potentially erroneous heuristics, and allows tools to
easily and unambiguously detect invalid content.</p>
<p>This avoids both false positive (<code class="docutils literal notranslate"><span class="pre">License</span></code> values that a package author
didn’t explicitly intend as an explicit SPDX identifier, but that happen
to validate as one), and false negatives (expressions the author intended
to be valid SPDX, but due to a typo or mistake are not), which are otherwise
not clearly distinguishable from true positives and negatives, an ambiguity
at odds with the goals of PEP 639.</p>
<p>Furthermore, it allows both the existing <code class="docutils literal notranslate"><span class="pre">License</span></code> field and
the license classifiers to be more easily deprecated,
with tools able to cleanly distinguish between packages intending to
affirmatively conform to the updated specification in PEP 639 or not,
and adapt their behavior (warnings, errors, etc) accordingly.
Otherwise, tools would either have to allow duplicative and potentially
conflicting <code class="docutils literal notranslate"><span class="pre">License</span></code> fields and classifiers, or warn/error on the
substantial number of existing packages that have SPDX identifiers as the
value for the <code class="docutils literal notranslate"><span class="pre">License</span></code> field, intentionally or otherwise (e.g. <code class="docutils literal notranslate"><span class="pre">MIT</span></code>).</p>
<p>Finally, it avoids changing the behavior of an existing metadata field,
and avoids tools having to guess the <code class="docutils literal notranslate"><span class="pre">Metadata-Version</span></code> and field behavior
based on its value rather than merely its presence.</p>
<p>While this would mean the subset of existing distributions containing
<code class="docutils literal notranslate"><span class="pre">License</span></code> fields valid as SPDX license expressions wouldn’t automatically be
recognized as such, this only requires appending a few characters to the key
name in the project’s source metadata, and PEP 639 provides extensive
guidance on how this can be done automatically by tooling.</p>
<p>Given all this, it was decided to proceed with defining a new,
purpose-created field, <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code>.</p>
</section>
<section id="re-use-the-license-field-with-a-value-prefix">
<h3>Re-Use the <code class="docutils literal notranslate"><span class="pre">License</span></code> field with a value prefix</h3>
<p>As an alternative to the previous, prefixing SPDX license expressions with,
e.g. <code class="docutils literal notranslate"><span class="pre">spdx:</span></code> was suggested to reduce the ambiguity inherent in re-using
the <code class="docutils literal notranslate"><span class="pre">License</span></code> field. However, this effectively amounted to creating
a field within a field, and doesn’t address all the downsides of
keeping the <code class="docutils literal notranslate"><span class="pre">License</span></code> field. Namely, it still changes the behavior of an
existing metadata field, requires tools to parse its value
to determine how to handle its content, and makes the specification and
deprecation process more complex and less clean.</p>
<p>Yet, it still shares a same main potential downside as just creating a new
field: projects currently using valid SPDX identifiers in the <code class="docutils literal notranslate"><span class="pre">License</span></code>
field, intentionally or not, won’t be automatically recognized, and requires
about the same amount of effort to fix, namely changing a line in the
project’s source metadata. Therefore, it was rejected in favor of a new field.</p>
</section>
<section id="don-t-make-license-expression-mutually-exclusive">
<h3>Don’t make <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> mutually exclusive</h3>
<p>For backwards compatibility, the <code class="docutils literal notranslate"><span class="pre">License</span></code> field and/or the license
classifiers could still be allowed together with the new
<code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field, presumably with a warning. However, this
could easily lead to inconsistent, and at the very least duplicative
license metadata in no less than <em>three</em> different fields, which is
squarely contrary to the goals of PEP 639 of making the licensing story
simpler and unambiguous. Therefore, and in concert with clear community
consensus otherwise, this idea was soundly rejected.</p>
</section>
<section id="don-t-deprecate-existing-license-field-and-classifiers">
<h3>Don’t deprecate existing <code class="docutils literal notranslate"><span class="pre">License</span></code> field and classifiers</h3>
<p>Several community members were initially concerned that deprecating the
existing <code class="docutils literal notranslate"><span class="pre">License</span></code> field and classifiers would result in
excessive churn for existing package authors and raise the barrier to
entry for new ones, particularly everyday Python developers seeking to
package and publish their personal projects without necessarily caring
too much about the legal technicalities or being a “license lawyer”.
Indeed, every deprecation comes with some non-zero short-term cost,
and should be carefully considered relative to the overall long-term
net benefit. And at the minimum, this change shouldn’t make it more
difficult for the average Python developer to share their work under
a license of their choice, and ideally improve the situation.</p>
<p>Following many rounds of proposals, discussion and refinement,
the general consensus was clearly in favor of deprecating the legacy
means of specifying a license, in favor of “one obvious way to do it”,
to improve the currently complex and fragmented story around license
documentation. Not doing so would leave three different un-deprecated ways of
specifying a license for a package, two of them ambiguous, less than
clear/obvious how to use, inconsistently documented and out of date.
This is more complex for all tools in the ecosystem to support
indefinitely (rather than simply installers supporting older packages
implementing previous frozen metadata versions), resulting in a non-trivial
and unbounded maintenance cost.</p>
<p>Furthermore, it leads to a more complex and confusing landscape for users with
three similar but distinct options to choose from, particularly with older
documentation, answers and articles floating around suggesting different ones.
Of the three, <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> is the simplest and clearest to use
correctly; users just paste in their desired license identifier, or select it
via a tool, and they’re done; no need to learn about Trove classifiers and
dig through the list to figure out which one(s) apply (and be confused
by many ambiguous options), or figure out on their own what should go
in the <code class="docutils literal notranslate"><span class="pre">license</span></code> key (anything from nothing, to the license text,
to a free-form description, to the same SPDX identifier they would be
entering in the <code class="docutils literal notranslate"><span class="pre">license</span></code> key anyway, assuming they can
easily find documentation at all about it). In fact, this can be
made even easier thanks to the new field. For example, GitHub’s popular
<a class="reference external" href="https://choosealicense.com/">ChooseALicense.com</a> links to how to add SPDX license
identifiers to the project source metadata of various languages that support
them right in the sidebar of every license page; the SPDX support in this
PEP enables adding Python to that list.</p>
<p>For current package maintainers who have specified a <code class="docutils literal notranslate"><span class="pre">License</span></code> or license
classifiers, PEP 639 only recommends warnings and prohibits errors for
all but publishing tools, which are allowed to error if their intended
distribution platform(s) so requires. Once maintainers are ready to
upgrade, for those already using SPDX license expressions (accidentally or not)
this only requires appending a few characters to the key name in the
project’s source metadata, and for those with license classifiers that
map to a single unambiguous license, or another defined case (public domain,
proprietary), they merely need to drop the classifier and paste in the
corresponding license identifier. PEP 639 provides extensive guidance and
examples, as will other resources, as well as explicit instructions for
automated tooling to take care of this with no human changes needed.
More complex cases where license metadata is currently specified may
need a bit of human intervention, but in most cases tools will be able
to provide a list of options following the mappings in PEP 639, and
these are typically the projects most likely to be constrained by the
limitations of the existing license metadata, and thus most benefited
by the new fields in PEP 639.</p>
<p>Finally, for unmaintained packages, those using tools supporting older
metadata versions, or those who choose not to provide license metadata,
no changes are required regardless of the deprecation.</p>
</section>
<section id="don-t-mandate-validating-new-fields-on-pypi">
<h3>Don’t mandate validating new fields on PyPI</h3>
<p>Previously, while PEP 639 did include normative guidelines for packaging
publishing tools (such as Twine), it did not provide specific guidance
for PyPI (or other package indices) as to whether and how they
should validate the <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> or <code class="docutils literal notranslate"><span class="pre">License-File</span></code> fields,
nor how they should handle using them in combination with the deprecated
<code class="docutils literal notranslate"><span class="pre">License</span></code> field or license classifiers. This simplifies the specification
and either defers implementation on PyPI to a later PEP, or gives
discretion to PyPI to enforce the stated invariants, to minimize
disruption to package authors.</p>
<p>However, this had been left unstated from before the <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code>
field was separate from the existing <code class="docutils literal notranslate"><span class="pre">License</span></code>, which would make
validation much more challenging and backwards-incompatible, breaking
existing packages. With that change, there was a clear consensus that
the new field should be validated from the start, guaranteeing that all
distributions uploaded to PyPI that declare core metadata version 2.4
or higher and have the <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field will have a valid
expression, such that PyPI and consumers of its packages and metadata
can rely upon to follow the specification here.</p>
<p>The same can be extended to the new <code class="docutils literal notranslate"><span class="pre">License-File</span></code> field as well,
to ensure that it is valid and the legally required license files are
present, and thus it is lawful for PyPI, users and downstream consumers
to distribute the package. (Of course, this makes no <em>guarantee</em> of such
as it is ultimately reliant on authors to declare them, but it improves
assurance of this and allows doing so in the future if the community so
decides.) To be clear, this would not require that any uploaded distribution
have such metadata, only that if they choose to declare it per the new
specification in PEP 639, it is assured to be valid.</p>
</section>
</section>
<section id="source-metadata-license-key">
<h2>Source metadata <code class="docutils literal notranslate"><span class="pre">license</span></code> key</h2>
<p>Alternate possibilities related to the <code class="docutils literal notranslate"><span class="pre">license</span></code> key in the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> project source metadata.</p>
<section id="add-expression-and-files-subkeys-to-table">
<h3>Add <code class="docutils literal notranslate"><span class="pre">expression</span></code> and <code class="docutils literal notranslate"><span class="pre">files</span></code> subkeys to table</h3>
<p>A previous working draft of PEP 639 added <code class="docutils literal notranslate"><span class="pre">expression</span></code> and <code class="docutils literal notranslate"><span class="pre">files</span></code> subkeys
to the existing <code class="docutils literal notranslate"><span class="pre">license</span></code> table in the project source metadata, to parallel
the existing <code class="docutils literal notranslate"><span class="pre">file</span></code> and <code class="docutils literal notranslate"><span class="pre">text</span></code> subkeys. While this seemed perhaps the
most obvious approach at first glance, it had several serious drawbacks
relative to that ultimately taken here.</p>
<p>Most saliently, this means two very different types of metadata are being
specified under the same top-level key that require very different handling,
and furthermore, unlike the previous arrangement, the subkeys were not mutually
exclusive and can both be specified at once, and with some subkeys potentially
being dynamic and others static, and mapping to different core metadata fields.</p>
<p>Furthermore, this leads to a conflict with marking the key as <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>
(assuming that is intended to specify the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table keys,
as that PEP seems to imprecisely imply,
rather than core metadata fields), as either or both would have
to be treated as <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.
Grouping both license expressions and license files under the same key
forces an “all or nothing” approach, and creates ambiguity as to user intent.</p>
<p>There are further downsides to this as well. Both users and tools would need to
keep track of which fields are mutually exclusive with which of the others,
greatly increasing cognitive and code complexity, and in turn the probability
of errors. Conceptually, juxtaposing so many different fields under the
same key is rather jarring, and leads to a much more complex mapping between
<code class="docutils literal notranslate"><span class="pre">[project]</span></code> keys and core metadata fields, not in keeping with <a class="pep reference internal" href="../pep-0621/">PEP 621</a>.
This causes the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table naming and structure to diverge further
from both the core metadata and native formats of the various popular packaging
tools that use it. Finally, this results in the spec being significantly more
complex and convoluted to understand and implement than the alternatives.</p>
<p>The approach PEP 639 now takes, using the reserved top-level string value
of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key, adding a new <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key
and deprecating the <code class="docutils literal notranslate"><span class="pre">license</span></code> table subkeys (<code class="docutils literal notranslate"><span class="pre">text</span></code> and <code class="docutils literal notranslate"><span class="pre">file</span></code>),
avoids most of the issues identified above,
and results in a much clearer and cleaner design overall.
It allows <code class="docutils literal notranslate"><span class="pre">license</span></code> and <code class="docutils literal notranslate"><span class="pre">license-files</span></code> to be tagged
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code> independently, separates two independent types of metadata
(syntactically and semantically), restores a closer to 1:1 mapping of
<code class="docutils literal notranslate"><span class="pre">[project]</span></code> table keys to core metadata fields,
and reduces nesting by a level for both.
Other than adding one extra key to the file, there was no significant
apparent downside to this latter approach, so it was adopted for PEP 639.</p>
</section>
<section id="add-an-expression-subkey-instead-of-a-string-value">
<h3>Add an <code class="docutils literal notranslate"><span class="pre">expression</span></code> subkey instead of a string value</h3>
<p>Adding just an <code class="docutils literal notranslate"><span class="pre">expression</span></code> subkey to the <code class="docutils literal notranslate"><span class="pre">license</span></code> table,
instead of using the reserved top-level string value,
would be more explicit for readers and writers,
in line with PEP 639’s goals.
However, it still has the downsides listed above
that are not specific to the inclusion of the <code class="docutils literal notranslate"><span class="pre">files</span></code> key.</p>
<p>Relative to a flat string value,
it adds verbosity, complexity and an extra level of nesting,
and requires users and tools to remember and handle
the mutual exclusivity of the subkeys
and remember which are deprecated and which are not,
instead of cleanly deprecating the table subkeys as a whole.
Furthermore, it is less clearly the “default” choice for modern use,
given users tend to gravitate toward the simplest and most obvious option.
Finally, it seems reasonable to follow the suggested guidance in <a class="pep reference internal" href="../pep-0621/">PEP 621</a>,
given the top-level string value was specifically reserved for this purpose.</p>
</section>
<section id="define-a-new-top-level-license-expression-key">
<h3>Define a new top-level <code class="docutils literal notranslate"><span class="pre">license-expression</span></code> key</h3>
<p>An earlier version of PEP 639 defined a new, top-level <code class="docutils literal notranslate"><span class="pre">license-expression</span></code>
under the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table,
rather than using the reserved string value of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key.
This was seen as clearer and more explicit for readers and writers,
in line with the goals of PEP 639.</p>
<p>Additionally, while differences from existing tool formats (and core metadata
field names) have precedent in <a class="pep reference internal" href="../pep-0621/">PEP 621</a>,
using a key with an identical name as in most/all current tools
to mean something different (and map to a different core metadata field),
with distinct and incompatible syntax and semantics, does not,
and could cause confusion and ambiguity for readers and authors.</p>
<p>Also, per the <a class="reference external" href="https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#dynamic">project source metadata spec</a>,
this would allow separately marking the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> keys
corresponding to the <code class="docutils literal notranslate"><span class="pre">License</span></code> and <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> metadata fields
as <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>,
avoiding a potential concern with back-filling the <code class="docutils literal notranslate"><span class="pre">License</span></code> field
from the <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field as PEP 639 currently allows
without it as <code class="docutils literal notranslate"><span class="pre">license</span></code> as dynamic
(which would not be possible, since they both map to the same top-level key).</p>
<p>However, community consensus favored using
the top-level string value of the existing <code class="docutils literal notranslate"><span class="pre">license</span></code> key,
as <a class="pep reference internal" href="../pep-0621/#license">reserved for this purpose by PEP 621</a>:</p>
<blockquote>
<div>A practical string value for the license key has been purposefully left
out to allow for a future PEP to specify support for SPDX expressions
(the same logic applies to any sort of “type” field specifying what
license the file or text represents).</div></blockquote>
<p>This is shorter and simpler for users to remember and type,
avoids adding a new top-level key while taking advantage of an existing one,
guides users toward using a license expression as the default,
and follows what was envisioned in the original <a class="pep reference internal" href="../pep-0621/">PEP 621</a>.</p>
<p>Additionally, this allows cleanly deprecating the table values
without deprecating the key itself,
and makes them inherently mutually exclusive without users having to remember
and tools having to enforce it.</p>
<p>Finally, consistency with other tool formats and the underlying core metadata
was not considered a sufficient priority
to override the advantages of using the existing key,
and the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> concerns were mostly mitigated by
not specifying legacy license to license expression conversion at build time,
explicitly specifying backfilling the <code class="docutils literal notranslate"><span class="pre">License</span></code> field when not <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>,
and the fact that both fields are mutually exclusive,
so there is little practical need to distinguish which is dynamic.</p>
<p>Therefore, a top-level string value for <code class="docutils literal notranslate"><span class="pre">license</span></code> was adopted for PEP 639,
as an earlier working draft had temporarily specified.</p>
</section>
<section id="add-a-type-key-to-treat-text-as-expression">
<h3>Add a <code class="docutils literal notranslate"><span class="pre">type</span></code> key to treat <code class="docutils literal notranslate"><span class="pre">text</span></code> as expression</h3>
<p>Instead of using the reserved top-level string value
of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key in the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table,
one could add a <code class="docutils literal notranslate"><span class="pre">type</span></code> subkey to the <code class="docutils literal notranslate"><span class="pre">license</span></code> table
to control whether <code class="docutils literal notranslate"><span class="pre">text</span></code> (or a string value)
is interpreted as free-text or a license expression. This could make
backward compatibility a little more seamless, as older tools could ignore
it and always treat <code class="docutils literal notranslate"><span class="pre">text</span></code> as <code class="docutils literal notranslate"><span class="pre">license</span></code>, while newer tools would
know to treat it as a license expression, if <code class="docutils literal notranslate"><span class="pre">type</span></code> was set appropriately.
Indeed, <a class="pep reference internal" href="../pep-0621/">PEP 621</a> seems to suggest something of this sort as a possible
alternative way that SPDX license expressions could be implemented.</p>
<p>However, all the same downsides as in the previous item apply here,
including greater complexity, a more complex mapping between the project
source metadata and core metadata and inconsistency between the presentation
in tool config, project source metadata and core metadata,
a much less clean deprecation, further bikeshedding over what to name it,
and inability to mark one but not the other as dynamic, among others.</p>
<p>In addition, while theoretically potentially a little easier in the short
term, in the long term it would mean users would always have to remember
to specify the correct <code class="docutils literal notranslate"><span class="pre">type</span></code> to ensure their license expression is
interpreted correctly, which adds work and potential for error; we could
never safety change the default while being confident that users
understand that what they are entering is unambiguously a license expression,
with all the false positive and false negative issues as above.</p>
<p>Therefore, for these as well as the same reasons this approach was rejected
for the core metadata in favor of a distinct <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field,
we similarly reject this here in favor of
the reserved string value of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key.</p>
</section>
<section id="must-be-marked-dynamic-to-back-fill">
<h3>Must be marked dynamic to back-fill</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">license</span></code> key in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> could be required to be
explicitly set to dynamic in order for the <code class="docutils literal notranslate"><span class="pre">License</span></code> core metadata field
to be automatically back-filled from
the top-level string value of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key.
This would be more explicit that the filling will be done,
as strictly speaking the <code class="docutils literal notranslate"><span class="pre">license</span></code> key is not (and cannot be) specified in
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>, and satisfies a stricter interpretation of the letter
of the previous <a class="pep reference internal" href="../pep-0621/">PEP 621</a> specification that PEP 639 revises.</p>
<p>However, this doesn’t seem to be necessary, because it is simply using the
static, verbatim literal value of the <code class="docutils literal notranslate"><span class="pre">license</span></code> key, as specified
strictly in PEP 639. Therefore, any conforming tool can trivially,
deterministically and unambiguously derive this using only the static data
in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file itself.</p>
<p>Furthermore, this actually adds significant ambiguity, as it means the value
could get filled arbitrarily by other tools, which would in turn compromise
and conflict with the value of the new <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> field, which is
why such is explicitly prohibited by PEP 639. Therefore, not marking it as
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code> will ensure it is only handled in accordance with PEP 639’s
requirements.</p>
<p>Finally, users explicitly being told to mark it as <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>, or not, to
control filling behavior seems to be a bit of a mis-use of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>
field as apparently intended, and prevents tools from adapting to best
practices (fill, don’t fill, etc) as they develop and evolve over time.</p>
</section>
</section>
<section id="source-metadata-license-files-key">
<h2>Source metadata <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key</h2>
<p>Alternatives considered for the <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key in the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table, primarily related to the
path/glob type handling.</p>
<section id="add-a-type-subkey-to-license-files">
<h3>Add a <code class="docutils literal notranslate"><span class="pre">type</span></code> subkey to <code class="docutils literal notranslate"><span class="pre">license-files</span></code></h3>
<p>Instead of defining mutually exclusive <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code> subkeys
of the <code class="docutils literal notranslate"><span class="pre">license-files</span></code> <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table key, we could
achieve the same effect with a <code class="docutils literal notranslate"><span class="pre">files</span></code> subkey for the list and
a <code class="docutils literal notranslate"><span class="pre">type</span></code> subkey for how to interpret it. However, the latter offers no
real advantage over the former, in exchange for requiring more keystrokes,
verbosity and complexity, as well as less flexibility in allowing both,
or another additional subkey in the future, as well as the need to bikeshed
over the subkey name. Therefore, it was summarily rejected.</p>
</section>
<section id="only-accept-verbatim-paths">
<h3>Only accept verbatim paths</h3>
<p>Globs could be disallowed completely as values to the <code class="docutils literal notranslate"><span class="pre">license-files</span></code>
key in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> and only verbatim literal paths allowed.
This would ensure that all license files are explicitly specified, all
specified license files are found and included, and the source metadata
is completely static in the strictest sense of the term, without tools
having to inspect the rest of the project source files to determine exactly
what license files will be included and what the <code class="docutils literal notranslate"><span class="pre">License-File</span></code> values
will be. This would also modestly simplify the spec and tool implementation.</p>
<p>However, practicality once again beats purity here. Globs are supported and
used by many existing tools for finding license files, and explicitly
specifying the full path to every license file would be unnecessarily tedious
for more complex projects with vendored code and dependencies. More
critically, it would make it much easier to accidentally miss a required
legal file, silently rendering the package illegal to distribute.</p>
<p>Tools can still statically and consistently determine the files to be included,
based only on those glob patterns the user explicitly specified and the
filenames in the package, without installing it, executing its code or even
examining its files. Furthermore, tools are still explicitly allowed to warn
if specified glob patterns (including full paths) don’t match any files.
And, of course, sdists, wheels and others will have the full static list
of files specified in their distribution metadata.</p>
<p>Perhaps most importantly, this would also preclude the currently specified
default value, as widely used by the current most popular tools, and thus
be a major break to backward compatibility, tool consistency, and safe
and sane default functionality to avoid unintentional license violations.
And of course, authors are welcome and encouraged to specify their license
files explicitly via the <code class="docutils literal notranslate"><span class="pre">paths</span></code> table subkey, once they are aware of it and
if it is suitable for their project and workflow.</p>
</section>
<section id="only-accept-glob-patterns">
<h3>Only accept glob patterns</h3>
<p>Conversely, all <code class="docutils literal notranslate"><span class="pre">license-files</span></code> strings could be treated as glob patterns.
This would slightly simplify the spec and implementation, avoid an extra level
of nesting, and more closely match the configuration format of existing tools.</p>
<p>However, for the cost of a few characters, it ensures users are aware
whether they are entering globs or verbatim paths. Furthermore, allowing
license files to be specified as literal paths avoids edge cases, such as those
containing glob characters (or those confusingly or even maliciously similar
to them, as described in <a class="pep reference internal" href="../pep-0672/">PEP 672</a>).</p>
<p>Including an explicit <code class="docutils literal notranslate"><span class="pre">paths</span></code> value ensures that the resulting
<code class="docutils literal notranslate"><span class="pre">License-File</span></code> metadata is correct, complete and purely static in the
strictest sense of the term, with all license paths explicitly specified
in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file, guaranteed to be included and with an early
error should any be missing. This is not practical to do, at least without
serious limitations for many workflows, if we must assume the items
are glob patterns rather than literal paths.</p>
<p>This allows tools to locate them and know the exact values of the
<code class="docutils literal notranslate"><span class="pre">License-File</span></code> core metadata fields without having to traverse the
source tree of the project and match globs, potentially allowing easier,
more efficient and reliable programmatic inspection and processing.</p>
<p>Therefore, given the relatively small cost and the significant benefits,
this approach was not adopted.</p>
</section>
<section id="infer-whether-paths-or-globs">
<h3>Infer whether paths or globs</h3>
<p>It was considered whether to simply allow specifying an array of strings
directly for the <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key, rather than making it a table with
explicit <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code>. This would be somewhat simpler and avoid
an extra level of nesting, and more closely match the configuration format
of existing tools. However, it was ultimately rejected in favor of separate,
mutually exclusive <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code> table subkeys.</p>
<p>In practice, it only saves six extra characters in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>
(<code class="docutils literal notranslate"><span class="pre">license-files</span> <span class="pre">=</span> <span class="pre">[...]</span></code> vs <code class="docutils literal notranslate"><span class="pre">license-files.globs</span> <span class="pre">=</span> <span class="pre">[...]</span></code>), but allows
the user to more explicitly declare their intent, ensures they understand how
the values are going to be interpreted, and serves as an unambiguous indicator
for tools to parse them as globs rather than verbatim path literals.</p>
<p>This, in turn, allows for more appropriate, clearly specified tool
behaviors for each case, many of which would be unreliable or impossible
without it, to avoid common traps, provide more helpful feedback and
behave more sensibly and intuitively overall. These include, with <code class="docutils literal notranslate"><span class="pre">paths</span></code>,
guaranteeing that each and every specified file is included and immediately
raising an error if one is missing, and with <code class="docutils literal notranslate"><span class="pre">globs</span></code>, checking glob syntax,
excluding unwanted backup, temporary, or other such files (as current tools
already do), and optionally warning if a glob doesn’t match any files.
This also avoids edge cases (e.g. paths that contain glob characters) and
reliance on heuristics to determine interpretation—the very thing PEP 639
seeks to avoid.</p>
</section>
<section id="also-allow-a-flat-array-value">
<span id="license-files-allow-flat-array"></span><h3>Also allow a flat array value</h3>
<p>Initially, after deciding to define <code class="docutils literal notranslate"><span class="pre">license-files</span></code> as a table of <code class="docutils literal notranslate"><span class="pre">paths</span></code>
and <code class="docutils literal notranslate"><span class="pre">globs</span></code>, thought was given to making a top-level string array under the
<code class="docutils literal notranslate"><span class="pre">license-files</span></code> key mean one or the other (probably <code class="docutils literal notranslate"><span class="pre">globs</span></code>, to match most
current tools). This is slightly shorter and simpler, would allow gently
nudging users toward a preferred one, and allow a slightly cleaner handling of
the empty case (which, at present, is treated identically for either).</p>
<p>However, this again only saves six characters in the best case, and there
isn’t an obvious choice; whether from a perspective of preference (both had
clear use cases and benefits), nor as to which one users would naturally
assume.</p>
<p>Flat may be better than nested, but in the face of ambiguity, users
may not resist the temptation to guess. Requiring users to explicitly specify
one or the other ensures they are aware of how their inputs will be handled,
and is more readable for others, both human and machine alike. It also makes
the spec and tool implementation slightly more complicated, and it can always
be added in the future, but not removed without breaking backward
compatibility. And finally, for the “preferred” option, it means there is
more than one obvious way to do it.</p>
<p>Therefore, per <a class="pep reference internal" href="../pep-0020/">PEP 20</a>, the Zen of Python, this approach is hereby rejected.</p>
</section>
<section id="allow-both-paths-and-globs-subkeys">
<h3>Allow both <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code> subkeys</h3>
<p>Allowing both <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code> subkeys to be specified under the
<code class="docutils literal notranslate"><span class="pre">license-files</span></code> table was considered, as it could potentially allow
more flexible handling for particularly complex projects, and specify on a
per-pattern rather than overall basis whether <code class="docutils literal notranslate"><span class="pre">license-files</span></code> entries
should be treated as <code class="docutils literal notranslate"><span class="pre">paths</span></code> or <code class="docutils literal notranslate"><span class="pre">globs</span></code>.</p>
<p>However, given the existing proposed approach already matches or exceeds the
power and capabilities of those offered in tools’ config files, there isn’t
clear demand for this and few likely cases that would benefit, it adds a large
amount of complexity for relatively minimal gain, in terms of the
specification, in tool implementations and in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> itself.</p>
<p>There would be many more edge cases to deal with, such as how to handle files
matched by both lists, and it conflicts in multiple places with the current
specification for how tools should behave with one or the other, such as when
no files match, guarantees of all files being included and of the file paths
being explicitly, statically specified, and others.</p>
<p>Like the previous, if there is a clear need for it, it can be always allowed
in the future in a backward-compatible manner (to the extent it is possible
in the first place), while the same is not true of disallowing it.
Therefore, it was decided to require the two subkeys to be mutually exclusive.</p>
</section>
<section id="rename-paths-subkey-to-files">
<h3>Rename <code class="docutils literal notranslate"><span class="pre">paths</span></code> subkey to <code class="docutils literal notranslate"><span class="pre">files</span></code></h3>
<p>Initially, it was considered whether to name the <code class="docutils literal notranslate"><span class="pre">paths</span></code> subkey of the
<code class="docutils literal notranslate"><span class="pre">license-files</span></code> table <code class="docutils literal notranslate"><span class="pre">files</span></code> instead. However, <code class="docutils literal notranslate"><span class="pre">paths</span></code> was ultimately
chosen, as calling the table subkey <code class="docutils literal notranslate"><span class="pre">files</span></code> resulted in duplication between
the table name (<code class="docutils literal notranslate"><span class="pre">license-files</span></code>) and the subkey name (<code class="docutils literal notranslate"><span class="pre">files</span></code>), i.e.
<code class="docutils literal notranslate"><span class="pre">license-files.files</span> <span class="pre">=</span> <span class="pre">[&quot;LICENSE.txt&quot;]</span></code>, made it seem like the preferred/
default subkey when it was not, and lacked the same parallelism with <code class="docutils literal notranslate"><span class="pre">globs</span></code>
in describing the format of the string entry rather than what was being
pointed to.</p>
</section>
<section id="must-be-marked-dynamic-to-use-defaults">
<h3>Must be marked dynamic to use defaults</h3>
<p>It may seem outwardly sensible, at least with a particularly restrictive
interpretation of <a class="pep reference internal" href="../pep-0621/">PEP 621</a>’s description of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> list, to
consider requiring the <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key to be explicitly marked as
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code> in order for the default glob patterns to be used, or alternatively
for license files to be matched and included at all.</p>
<p>However, this is merely declaring a static, strictly-specified default value
for this particular key, required to be used exactly by all conforming tools
(so long as it is not marked <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>, negating this argument entirely),
and is no less static than any other set of glob patterns the user themself
may specify. Furthermore, the resulting <code class="docutils literal notranslate"><span class="pre">License-File</span></code> core metadata values
can still be determined with only a list of files in the source, without
installing or executing any of the code, or even inspecting file contents.</p>
<p>Moreover, even if this were not so, practicality would trump purity, as this
interpretation would be strictly backwards-incompatible with the existing
format, and be inconsistent with the behavior with the existing tools.
Further, this would create a very serious and likely risk of a large number of
projects unknowingly no longer including legally mandatory license files,
making their distribution technically illegal, and is thus not a sane,
much less sensible default.</p>
<p>Finally, aside from adding an additional line of default-required boilerplate
to the file, not defining the default as dynamic allows authors to clearly
and unambiguously indicate when their build/packaging tools are going to be
handling the inclusion of license files themselves rather than strictly
conforming to the project source metadata portions of PEP 639;
to do otherwise would defeat the primary purpose of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> list
as a marker and escape hatch.</p>
</section>
</section>
<section id="license-file-paths">
<h2>License file paths</h2>
<p>Alternatives related to the paths and locations of license files in the source
and built distributions.</p>
<section id="flatten-license-files-in-subdirectories">
<h3>Flatten license files in subdirectories</h3>
<p>Previous drafts of PEP 639 were silent on the issue of handling license files
in subdirectories. Currently, the <a class="reference external" href="https://github.com/pypa/wheel/issues/138">Wheel</a> and (following its
example) <a class="reference external" href="https://github.com/pypa/setuptools/issues/2739">Setuptools</a> projects flatten all license files
into the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory without preserving the source subdirectory
hierarchy.</p>
<p>While this is the simplest approach and matches existing ad hoc practice,
this can result in name conflicts and license files clobbering others,
with no obvious defined behavior for how to resolve them, and leaving the
package legally un-distributable without any clear indication to users that
their specified license files have not been included.</p>
<p>Furthermore, this leads to inconsistent relative file paths for non-root
license files between the source, sdist and wheel, and prevents the paths
given in the “static” <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table metadata from being truly static,
as they need to be flattened, and may potentially overwrite one another.
Finally, the source directory structure often implies valuable information
about what the licenses apply to, and where to find them in the source,
which is lost when flattening them and far from trivial to reconstruct.</p>
<p>To resolve this, the PEP now proposes, as did contributors on both of the
above issues, reproducing the source directory structure of the original
license files inside the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory. This would fully resolve the
concerns above, with the only downside being a more nested <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code>
directory. There is still a risk of collision with edge-case custom
filenames (e.g. <code class="docutils literal notranslate"><span class="pre">RECORD</span></code>, <code class="docutils literal notranslate"><span class="pre">METADATA</span></code>), but that is also the case
with the previous approach, and in fact with fewer files flattened
into the root, this would actually reduce the risk. Furthermore,
the following proposal rooting the license files under a <code class="docutils literal notranslate"><span class="pre">licenses</span></code>
subdirectory eliminates both collisions and the clutter problem entirely.</p>
</section>
<section id="resolve-name-conflicts-differently">
<h3>Resolve name conflicts differently</h3>
<p>Rather than preserving the source directory structure for license files
inside the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory, we could specify some other mechanism
for conflict resolution, such as pre- or appending the parent directory name
to the license filename, traversing up the tree until the name was unique,
to avoid excessively nested directories.</p>
<p>However, this would not address the path consistency issues, would require
much more discussion, coordination and bikeshedding, and further complicate
the specification and the implementations. Therefore, it was rejected in
favor of the simpler and more obvious solution of just preserving the
source subdirectory layout, as many stakeholders have already advocated for.</p>
</section>
<section id="dump-directly-in-dist-info">
<h3>Dump directly in <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code></h3>
<p>Previously, the included license files were stored directly in the top-level
<code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory of built wheels and installed projects. This followed
existing ad hoc practice, ensured most existing wheels currently using this
feature will match new ones, and kept the specification simpler, with the
license files always being stored in the same location relative to the core
metadata regardless of distribution type.</p>
<p>However, this leads to a more cluttered <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory, littered
with arbitrary license files and subdirectories, as opposed to separating
licenses into their own namespace (which per the Zen of Python, <a class="pep reference internal" href="../pep-0020/">PEP 20</a>, are
“one honking great idea”). While currently small, there is still a
risk of collision with specific custom license filenames
(e.g. <code class="docutils literal notranslate"><span class="pre">RECORD</span></code>, <code class="docutils literal notranslate"><span class="pre">METADATA</span></code>) in the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory, which
would only increase if and when additional files were specified here, and
would require carefully limiting the potential filenames used to avoid
likely conflicts with those of license-related files. Finally,
putting licenses into their own specified subdirectory would allow
humans and tools to quickly, easily and correctly list, copy and manipulate
all of them at once (such as in distro packaging, legal checks, etc)
without having to reference each of their paths from the core metadata.</p>
<p>Therefore, now is a prudent time to specify an alternate approach.
The simplest and most obvious solution, as suggested by several on the Wheel
and Setuptools implementation issues, is to simply root the license files
relative to a <code class="docutils literal notranslate"><span class="pre">licenses</span></code> subdirectory of <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code>. This is simple
to implement and solves all the problems noted here, without clear significant
drawbacks relative to other more complex options.</p>
<p>It does make the specification a bit more complex and less elegant, but
implementation should remain equally simple. It does mean that wheels
produced with following this change will have differently-located licenses
than those prior, but as this was already true for those in subdirectories,
and until PEP 639 there was no way of discovering these files or
accessing them programmatically, this doesn’t seem likely to pose
significant problems in practice. Given this will be much harder if not
impossible to change later, once the status quo is standardized, tools are
relying on the current behavior and there is much greater uptake of not
only simply including license files but potentially accessing them as well
using the core metadata, if we’re going to change it, now would be the time
(particularly since we’re already introducing an edge-case change with how
license files in subdirs are handled, along with other refinements).</p>
<p>Therefore, the latter has been incorporated into current drafts of PEP 639.</p>
</section>
<section id="add-new-licenses-category-to-wheel">
<h3>Add new <code class="docutils literal notranslate"><span class="pre">licenses</span></code> category to wheel</h3>
<p>Instead of defining a root license directory (<code class="docutils literal notranslate"><span class="pre">licenses</span></code>) inside
the core metadata directory (<code class="docutils literal notranslate"><span class="pre">.dist-info</span></code>) for wheels, we could instead
define a new category (and, presumably, a corresponding install scheme),
similar to the others currently included under <code class="docutils literal notranslate"><span class="pre">.data</span></code> in the wheel archive,
specifically for license files, called (e.g.) <code class="docutils literal notranslate"><span class="pre">licenses</span></code>. This was mentioned
by the wheel creator, and would allow installing licenses somewhere more
platform-appropriate and flexible than just the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory
in the site path, and potentially be conceptually cleaner than including
them there.</p>
<p>However, at present, PEP 639 does not implement this idea, and it is
deferred to a future one. It would add significant complexity and friction
to PEP 639, being primarily concerned with standardizing existing practice
and updating the core metadata specification. Furthermore, doing so would
likely require modifying <code class="docutils literal notranslate"><span class="pre">sysconfig</span></code> and the install schemes specified
therein, alongside Wheel, Installer and other tools, which would be a
non-trivial undertaking. While potentially slightly more complex for
repackagers (such as those for Linux distributions), the current proposal still
ensures all license files are included, and in a single dedicated directory
(which can easily be copied or relocated downstream), and thus should still
greatly improve the status quo in this regard without the attendant complexity.</p>
<p>In addition, this approach is not fully backwards compatible (since it
isn’t transparent to tools that simply extract the wheel), is a greater
departure from existing practice and would lead to more inconsistent
license install locations from wheels of different versions. Finally,
this would mean licenses would not be installed as proximately to their
associated code, there would be more variability in the license root path
across platforms and between built distributions and installed projects,
accessing installed licenses programmatically would be more difficult, and a
suitable install location and method would need to be created, discussed
and decided that would avoid name clashes.</p>
<p>Therefore, to keep PEP 639 in scope, the current approach was retained.</p>
</section>
<section id="name-the-subdirectory-license-files">
<h3>Name the subdirectory <code class="docutils literal notranslate"><span class="pre">license_files</span></code></h3>
<p>Both <code class="docutils literal notranslate"><span class="pre">licenses</span></code> and <code class="docutils literal notranslate"><span class="pre">license_files</span></code> have been suggested as potential
names for the root license directory inside <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> of wheels and
installed projects. An initial draft of the PEP specified the former
due to being slightly clearer and consistent with the
name of the core metadata field (<code class="docutils literal notranslate"><span class="pre">License-File</span></code>)
and the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> table key (<code class="docutils literal notranslate"><span class="pre">license-files</span></code>).
However, the current version of the PEP adopts the <code class="docutils literal notranslate"><span class="pre">license</span></code> name,
due to a general preference by the community for its shorter length,
greater simplicity and the lack of a separator character (<code class="docutils literal notranslate"><span class="pre">_</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, etc.).</p>
</section>
</section>
<section id="other-ideas">
<h2>Other ideas</h2>
<p>Miscellaneous proposals, possibilities and discussion points that were
ultimately not adopted.</p>
<section id="map-identifiers-to-license-files">
<h3>Map identifiers to license files</h3>
<p>This would require using a mapping (as two parallel lists would be too prone to
alignment errors), which would add extra complexity to how license
are documented and add an additional nesting level.</p>
<p>A mapping would be needed, as it cannot be guaranteed that all expressions
(keys) have a single license file associated with them (e.g.
GPL with an exception may be in a single file) and that any expression
does not have more than one. (e.g. an Apache license <code class="docutils literal notranslate"><span class="pre">LICENSE</span></code> and
its <code class="docutils literal notranslate"><span class="pre">NOTICE</span></code> file, for instance, are two distinct files).
For most common cases, a single license expression and one or more license
files would be perfectly adequate. In the rarer and more complex cases where
there are many licenses involved, authors can still safety use the fields
specified here, just with a slight loss of clarity by not specifying which
text file(s) map to which license identifier (though this should be clear in
practice given each license identifier has corresponding SPDX-registered
full license text), while not forcing the more complex data model
(a mapping) on the large majority of users who do not need or want it.</p>
<p>We could of course have a data field with multiple possible value types (it’s a
string, it’s a list, it’s a mapping!) but this could be a source of confusion.
This is what has been done, for instance, in npm (historically) and in Rubygems
(still today), and as result tools need to test the type of the metadata field
before using it in code, while users are confused about when to use a list or a
string. Therefore, this approach is rejected.</p>
</section>
<section id="map-identifiers-to-source-files">
<h3>Map identifiers to source files</h3>
<p>As discussed previously, file-level notices are out of scope for PEP 639,
and the existing <code class="docutils literal notranslate"><span class="pre">SPDX-License-Identifier</span></code> <a class="reference external" href="https://spdx.dev/ids/">convention</a> can
already be used if this is needed without further specification here.</p>
</section>
<section id="don-t-freeze-compatibility-with-a-specific-spdx-version">
<h3>Don’t freeze compatibility with a specific SPDX version</h3>
<p>PEP 639 could omit specifying a specific SPDX specification version,
or one for the list of valid license identifiers, which would allow
more flexible updates as the specification evolves without another
PEP or equivalent.</p>
<p>However, serious concerns were expressed about a future SPDX update breaking
compatibility with existing expressions and identifiers, leaving current
packages with invalid metadata per the definition in PEP 639. Requiring
compatibility with a specific version of these specifications here
and a PEP or similar process to update it avoids this contingency,
and follows the practice of other packaging ecosystems.</p>
<p>Therefore, it was <a class="reference external" href="https://github.com/pombredanne/spdx-pypi-pep/issues/6">decided</a> to specify a minimum version
and requires tools to be compatible with it, while still allowing updates
so long as they don’t break backward compatibility. This enables
tools to immediate take advantage of improvements and accept new
licenses, but also remain backwards compatible with the version
specified here, balancing flexibility and compatibility.</p>
</section>
<section id="different-licenses-for-source-and-binary-distributions">
<span id="rejected-ideas-difference-license-source-binary"></span><h3>Different licenses for source and binary distributions</h3>
<p>As an additional use case, it was asked whether it was in scope for this
PEP to handle cases where the license expression for a binary distribution
(wheel) is different from that for a source distribution (sdist), such
as in cases of non-pure-Python packages that compile and bundle binaries
under different licenses than the project itself. An example cited was
<a class="reference external" href="https://pypi.org/project/torch/">PyTorch</a>, which contains CUDA from Nvidia, which is freely
distributable but not open source. <a class="reference external" href="https://github.com/numpy/numpy/issues/8689">NumPy</a> and
<a class="reference external" href="https://github.com/scipy/scipy/issues/7093">SciPy</a> also had similar issues, as reported by the
original author of PEP 639 and now resolved for those cases.</p>
<p>However, given the inherent complexity here and a lack of an obvious
mechanism to do so, the fact that each wheel would need its own license
information, lack of support on PyPI for exposing license info on a
per-distribution archive basis, and the relatively niche use case, it was
determined to be out of scope for PEP 639, and left to a future PEP
to resolve if sufficient need and interest exists and an appropriate
mechanism can be found.</p>
</section>
</section>
</section>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#core-metadata-fields">Core metadata fields</a><ul>
<li><a class="reference internal" href="#re-use-the-license-field">Re-use the <code class="docutils literal notranslate"><span class="pre">License</span></code> field</a></li>
<li><a class="reference internal" href="#re-use-the-license-field-with-a-value-prefix">Re-Use the <code class="docutils literal notranslate"><span class="pre">License</span></code> field with a value prefix</a></li>
<li><a class="reference internal" href="#don-t-make-license-expression-mutually-exclusive">Don’t make <code class="docutils literal notranslate"><span class="pre">License-Expression</span></code> mutually exclusive</a></li>
<li><a class="reference internal" href="#don-t-deprecate-existing-license-field-and-classifiers">Don’t deprecate existing <code class="docutils literal notranslate"><span class="pre">License</span></code> field and classifiers</a></li>
<li><a class="reference internal" href="#don-t-mandate-validating-new-fields-on-pypi">Don’t mandate validating new fields on PyPI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-metadata-license-key">Source metadata <code class="docutils literal notranslate"><span class="pre">license</span></code> key</a><ul>
<li><a class="reference internal" href="#add-expression-and-files-subkeys-to-table">Add <code class="docutils literal notranslate"><span class="pre">expression</span></code> and <code class="docutils literal notranslate"><span class="pre">files</span></code> subkeys to table</a></li>
<li><a class="reference internal" href="#add-an-expression-subkey-instead-of-a-string-value">Add an <code class="docutils literal notranslate"><span class="pre">expression</span></code> subkey instead of a string value</a></li>
<li><a class="reference internal" href="#define-a-new-top-level-license-expression-key">Define a new top-level <code class="docutils literal notranslate"><span class="pre">license-expression</span></code> key</a></li>
<li><a class="reference internal" href="#add-a-type-key-to-treat-text-as-expression">Add a <code class="docutils literal notranslate"><span class="pre">type</span></code> key to treat <code class="docutils literal notranslate"><span class="pre">text</span></code> as expression</a></li>
<li><a class="reference internal" href="#must-be-marked-dynamic-to-back-fill">Must be marked dynamic to back-fill</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-metadata-license-files-key">Source metadata <code class="docutils literal notranslate"><span class="pre">license-files</span></code> key</a><ul>
<li><a class="reference internal" href="#add-a-type-subkey-to-license-files">Add a <code class="docutils literal notranslate"><span class="pre">type</span></code> subkey to <code class="docutils literal notranslate"><span class="pre">license-files</span></code></a></li>
<li><a class="reference internal" href="#only-accept-verbatim-paths">Only accept verbatim paths</a></li>
<li><a class="reference internal" href="#only-accept-glob-patterns">Only accept glob patterns</a></li>
<li><a class="reference internal" href="#infer-whether-paths-or-globs">Infer whether paths or globs</a></li>
<li><a class="reference internal" href="#also-allow-a-flat-array-value">Also allow a flat array value</a></li>
<li><a class="reference internal" href="#allow-both-paths-and-globs-subkeys">Allow both <code class="docutils literal notranslate"><span class="pre">paths</span></code> and <code class="docutils literal notranslate"><span class="pre">globs</span></code> subkeys</a></li>
<li><a class="reference internal" href="#rename-paths-subkey-to-files">Rename <code class="docutils literal notranslate"><span class="pre">paths</span></code> subkey to <code class="docutils literal notranslate"><span class="pre">files</span></code></a></li>
<li><a class="reference internal" href="#must-be-marked-dynamic-to-use-defaults">Must be marked dynamic to use defaults</a></li>
</ul>
</li>
<li><a class="reference internal" href="#license-file-paths">License file paths</a><ul>
<li><a class="reference internal" href="#flatten-license-files-in-subdirectories">Flatten license files in subdirectories</a></li>
<li><a class="reference internal" href="#resolve-name-conflicts-differently">Resolve name conflicts differently</a></li>
<li><a class="reference internal" href="#dump-directly-in-dist-info">Dump directly in <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code></a></li>
<li><a class="reference internal" href="#add-new-licenses-category-to-wheel">Add new <code class="docutils literal notranslate"><span class="pre">licenses</span></code> category to wheel</a></li>
<li><a class="reference internal" href="#name-the-subdirectory-license-files">Name the subdirectory <code class="docutils literal notranslate"><span class="pre">license_files</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-ideas">Other ideas</a><ul>
<li><a class="reference internal" href="#map-identifiers-to-license-files">Map identifiers to license files</a></li>
<li><a class="reference internal" href="#map-identifiers-to-source-files">Map identifiers to source files</a></li>
<li><a class="reference internal" href="#don-t-freeze-compatibility-with-a-specific-spdx-version">Don’t freeze compatibility with a specific SPDX version</a></li>
<li><a class="reference internal" href="#different-licenses-for-source-and-binary-distributions">Different licenses for source and binary distributions</a></li>
</ul>
</li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0639/appendix-rejected-ideas.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../../_static/colour_scheme.js"></script>
    <script src="../../_static/wrap_tables.js"></script>
    <script src="../../_static/sticky_banner.js"></script>
</body>
</html>